# The Challenge

Build a small Multi-Tenant Invoice Reconciliation API using:

- Python 3.13
- FastAPI (REST)
- Strawberry GraphQL
- SQLAlchemy 2.0

The scope is intentionally contained, but the requirements are designed to surface senior-level engineering decisions: transaction boundaries, idempotency, multi-tenant isolation, and pragmatic AI integration.

---

## Requirements

### Core Concepts

Your system supports multiple organizations (tenants). Each tenant can:

- Create and list invoices
- Import bank transactions (bulk)
- Run a reconciliation process that proposes matches between invoices and bank transactions
- Confirm a match (finalize it)
- Request an AI explanation of a match decision

Multi-tenancy is mandatory: tenant data must be isolated.

---

### Data Model (Minimum)

You may extend as needed, but keep it focused.

#### Tenant

- id
- name
- created_at

#### Vendor
• id
• tenant_id
• name
• created_at

Invoice

- id
- tenant_id
- vendor_id (optional, if you include vendors)
- invoice_number (optional)
- amount (required)
- currency (optional, default USD)
- invoice_date (optional)
- description (optional)
- status (e.g., open, matched, paid)
- created_at

#### BankTransaction

- id
- tenant_id
- external_id (optional but recommended)
- posted_at (date/time)
- amount (required)
- currency (optional, default USD)
- description (bank memo)
- created_at

#### MatchCandidate / Match (your choice)

You can model this as:

- a "candidate" generated by reconciliation + a "confirmed match", or
- a single table with status = proposed|confirmed|rejected

Must include at minimum:

- id
- tenant_id
- invoice_id
- bank_transaction_id
- score (numeric confidence)
- status
- created_at

---

## APIs

### REST (FastAPI)

All endpoints must be tenant-scoped (path or header). Recommended style:

#### Tenants

- `POST /tenants` – create tenant
- `GET /tenants` – list tenants (optional)

#### Invoices

- `POST /tenants/{tenant_id}/invoices` – create invoice
- `GET /tenants/{tenant_id}/invoices` – list invoices
  - Include filtering: status, vendor, date range, amount range (at least 2 filters)
- `DELETE /tenants/{tenant_id}/invoices/{id}` – delete invoice

#### Bank Transactions

- `POST /tenants/{tenant_id}/bank-transactions/import` – bulk import bank transactions
  - Accept a list payload.
  - Must support idempotency (see below).

#### Reconciliation

- `POST /tenants/{tenant_id}/reconcile` – run reconciliation and return match candidates
  - Return best candidates per invoice and/or per transaction (your design, explain in README).
- `POST /tenants/{tenant_id}/matches/{match_id}/confirm` – confirm a proposed match

#### AI Explanation

- `GET /tenants/{tenant_id}/reconcile/explain?invoice_id=...&transaction_id=...`
  - Returns a natural-language explanation of the likely match decision.
- If AI is unavailable, return a deterministic fallback explanation.

---

### GraphQL (Strawberry)

GraphQL must rely on the same service layer used by REST.

Implement at minimum:

#### Queries

- `tenants`
- `invoices(tenantId, filters, pagination)`
- `bankTransactions(tenantId, filters, pagination)` (optional but recommended)
- `matchCandidates(tenantId, filters)` (optional if you return reconciliation output directly)
- `explainReconciliation(tenantId, invoiceId, transactionId)`

#### Mutations

- `createTenant(input)`
- `createInvoice(tenantId, input)`
- `deleteInvoice(tenantId, invoiceId)`
- `importBankTransactions(tenantId, input, idempotencyKey)`
- `reconcile(tenantId, input?)`
- `confirmMatch(tenantId, matchId)`

---

## AI Requirement (Pragmatic)

Implement a simple AI-powered explanation layer.

### Guidelines

- You may use an LLM (OpenAI, Anthropic, local model, or mocked client).
- AI should receive only tenant-authorized data as context:
  - invoice amount/date/vendor/description
  - transaction amount/date/description
  - any heuristic score you compute
- The AI returns:
  - A short explanation (2–6 sentences), and optionally a confidence label.
- Focus is integration and design, not training.
- Credentials must be configurable (env vars, config file, etc.).
- Must implement graceful failure:
  - If AI errors/timeouts/missing key → return a deterministic explanation.

Mocking the AI layer in tests is acceptable (encouraged).

---

## Reconciliation Rules (Non-AI Core)

AI should not be the main matching engine.

Implement deterministic heuristics such as:

- Exact amount match (strong)
- Amount match within tolerance (optional)
- Date proximity (e.g., within ±3 days)
- Text similarity heuristic (simple contains/ratio is fine)
- Vendor name hint (optional)

Produce a score that drives candidate ranking.

Explain your scoring in README.

---

## Database Requirements

- Use SQLAlchemy 2.0 style
- SQLite is acceptable for local use
- Correct session/transaction management
- Enforce multi-tenancy:
  - Every table is tenant-scoped (except tenants)
  - All reads/writes are filtered by tenant_id

## Idempotency Requirement (Important)

`POST /bank-transactions/import` must be idempotent.

Implement via Idempotency-Key (header) or explicit field:

- If the same idempotency key is used again with the same payload, return the same result.
- If the same key is reused with a different payload, return a conflict error (409) or equivalent.

---

## Testing (pytest)

Include tests for:

1. Creating invoices
2. Listing invoices (including at least one filter)
3. Deleting invoices
4. Importing bank transactions (including idempotency)
5. Reconciliation produces candidates with expected ranking behavior (basic deterministic test)
6. Confirming a match updates expected state
7. AI explanation endpoint (mocked AI + fallback path)

---

## What We're Evaluating

We’re looking for senior-level signals:

- Clean architecture / separation of concerns (API vs service vs persistence)
- Multi-tenant isolation correctness
- Good transaction boundaries + idempotency handling
- Pragmatic AI integration (well-contained, mockable, resilient)
- Code clarity, typing, and test quality
- Thoughtful tradeoffs and documentation

You may use AI tools while building this. We're evaluating the final result and how well it holds together.

---

## Submission

Please submit:

- A Git repository or zip file containing the solution
- A short README with:
  - Setup and run instructions
  - Key design decisions and tradeoffs
  - How you approached reconciliation scoring and idempotency
  - Tests that run locally

This challenge should take a few hours. Focus on clarity, correctness, and maintainability over completeness.